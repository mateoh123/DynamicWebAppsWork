{"ast":null,"code":"var _jsxFileName = \"/Users/mateohernandez/Desktop/DynWeb/dynamicwebmidterm/src/components/Dropdown.js\",\n  _s = $RefreshSig$();\nimport { useState, useEffect, useRef } from 'react';\nimport { GoChevronDown } from 'react-icons/go';\nimport Panel from './Panel';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Dropdown = props => {\n  _s();\n  const {\n    options,\n    onChange,\n    value\n  } = props;\n  // local state\n  const [isOpen, setIsOpen] = useState(false);\n  const divEl = useRef();\n  // scroll down to our returned JSX, we are assigning the outer div containing our dropdown\n  // to the variable divEl:\n  // <div className=\"w-48 relative\" ref={divEl}>\n\n  // useEffect depending on what you pass it\n  // will fire once when the component first mounts []\n  // every time the comonent re-renders no second argument\n  // every time a var updates because we tell useEffect to watch it [someValueToWatch]\n\n  // now we need to add an event listener to reference our useRef value\n  // USE EFFECT HOOK\n  // use effect takes 2 arguments\n  // the first is the function you want to call\n  // the second is an array of props, state, any js variables available to this component to watch\n\n  // use effect fires when the component mounts (first time is renders on the screen aka initial render)\n  // if anything is in the second array,\n  // these are js vars aka state, variables, props\n  // these are items we a watching. if one of those variables changes, use effect will fire the function from the first argument again\n\n  // useEffect depending on what you pass it\n  // will fire once when the component first mounts []\n  // every time the comonent re-renders no second argument\n  // every time a var updates because we tell useEffect to watch it [someValueToWatch]\n  // OR\n  // fire the first time the component mounts\n  // this is really great for API calls or adding event listeners the old fashion way\n  // const useEffect(() => {}, [])\n  // fire on mount, and everytime the value uof myPeiceOfState changes\n  // const useEffect(() => {}, [myPieceOfState])\n  // if no second argument, it will fire every time the component re-renders\n  // const useEffect(() => {})\n\n  // fire once on mount to add event listener,\n  // if the function in the first agrument returns another function\n  // thats gets fired when the component is detroyed\n  // this is a cleanup function\n\n  /*\n  in our case, we want to add an event listener that:\n  listens for a click, and checks the event.target\n  WHY?\n  to close our dropdown when we click off our dropdown menu\n  (we opened the dropdown menu, but we never made a selection, and we then click off the dropdown anywhere else on the page!)\n  IMPORTANT STEP:\n  make sure you watch our divEl ref in our useEffect!!!\n  const useEffect(() => {}, [divEl])\n  IF YOU DONT:\n  the arrow function will only run ONCE ON MOUNT,\n  things will seem to work MOST of the time, but once the component is destroyed, a few too many clicks and you'll get an error screen\n  */\n  useEffect(() => {\n    // check the element assigned to const divEl (the most parent div in our dropdown)\n    // if what we just clicked is outside of this component\n    // close our dropdown!\n    const handler = event => {\n      // check that divEl.current exists before AND that it does not contain the event target\n      if (divEl.current && !divEl.current.contains(event.target)) {\n        setIsOpen(false);\n        console.log('clicked outside dropdown');\n      }\n    };\n\n    // add the event listener, this is for clicks OUTSIDE our dropdown component\n    // because of the conditional check above\n    document.addEventListener('click', handler, true);\n\n    // whenever we assign an event listener the old fashioned way : document.addEventListener\n    // we do it using useEffect(()=>{}, []) -  empty array as second argument!\n    // if we added an event listener without useEffect,\n    // it will add an event listener EVERY time the component re-renders!\n\n    // we have an event listener that affects our component,\n    // return a cleanup function to remove the event listener,\n    // if we dont, this event listener will hang around after\n    // our dropdown is no longer on the page and cause issues :(\n\n    // returned function inside useEffects first argument is fired whenever the component is destroyed\n    return () => {\n      document.removeEventListener('click', handler);\n    };\n  }, [divEl]);\n  const handleClick = () => {\n    setIsOpen(!isOpen);\n  };\n  const handleOptionClick = option => {\n    setIsOpen(false);\n    // need some other function defined by the\n    // parent component passed in as a prop to call here\n    onChange(option);\n  };\n  const renderedOptions = options.map((opt, index) => {\n    // this is where we assign an element on the page to our divEl var!\n    // WHY? because we this components state (isOpen) to change when we click\n    // OUTSIDE THIS COMPONENT\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      onClick: () => handleOptionClick(opt),\n      className: \"hover:bg-sky-100 rounded cursor-pointer p-1\",\n      children: opt.label\n    }, index, false, {\n      fileName: _jsxFileName,\n      lineNumber: 110,\n      columnNumber: 7\n    }, this);\n  });\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: divEl,\n    className: \"w-48 relative\",\n    children: [/*#__PURE__*/_jsxDEV(Panel, {\n      onClick: handleClick,\n      className: \"flex justify-between items-center cursor-pointer\",\n      children: [value ? value.label : 'Select...', \" \", /*#__PURE__*/_jsxDEV(GoChevronDown, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 128,\n        columnNumber: 45\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 122,\n      columnNumber: 7\n    }, this), isOpen && /*#__PURE__*/_jsxDEV(Panel, {\n      className: \"absolute top-full\",\n      children: renderedOptions\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 130,\n      columnNumber: 18\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 121,\n    columnNumber: 5\n  }, this);\n};\n\n/* moved to own file!\nconst Panel = (props) => {\n  const {className, children, ...rest} = props\n  const finalClassNames = cx(\n    className,\n    'border rounded p-3 shadow bg-white w-full'\n  )\n  return (\n    <div {...rest} className={finalClassNames}>\n      {children}\n    </div>\n  )\n}\n\n// named export\nexport {Panel}\n*/\n\n// default export (usually the file name should give you a hint about what to be the default export)\n_s(Dropdown, \"vOq9QTgDS0u9AJtv1ufd9s5HWrI=\");\n_c = Dropdown;\nexport default Dropdown;\nvar _c;\n$RefreshReg$(_c, \"Dropdown\");","map":{"version":3,"names":["useState","useEffect","useRef","GoChevronDown","Panel","jsxDEV","_jsxDEV","Dropdown","props","_s","options","onChange","value","isOpen","setIsOpen","divEl","handler","event","current","contains","target","console","log","document","addEventListener","removeEventListener","handleClick","handleOptionClick","option","renderedOptions","map","opt","index","onClick","className","children","label","fileName","_jsxFileName","lineNumber","columnNumber","ref","_c","$RefreshReg$"],"sources":["/Users/mateohernandez/Desktop/DynWeb/dynamicwebmidterm/src/components/Dropdown.js"],"sourcesContent":["import {useState, useEffect, useRef} from 'react'\nimport {GoChevronDown} from 'react-icons/go'\nimport Panel from './Panel'\n\nconst Dropdown = (props) => {\n  const {options, onChange, value} = props\n  // local state\n  const [isOpen, setIsOpen] = useState(false)\n\n  const divEl = useRef()\n  // scroll down to our returned JSX, we are assigning the outer div containing our dropdown\n  // to the variable divEl:\n  // <div className=\"w-48 relative\" ref={divEl}>\n\n  // useEffect depending on what you pass it\n  // will fire once when the component first mounts []\n  // every time the comonent re-renders no second argument\n  // every time a var updates because we tell useEffect to watch it [someValueToWatch]\n\n  // now we need to add an event listener to reference our useRef value\n  // USE EFFECT HOOK\n  // use effect takes 2 arguments\n  // the first is the function you want to call\n  // the second is an array of props, state, any js variables available to this component to watch\n\n  // use effect fires when the component mounts (first time is renders on the screen aka initial render)\n  // if anything is in the second array,\n  // these are js vars aka state, variables, props\n  // these are items we a watching. if one of those variables changes, use effect will fire the function from the first argument again\n\n  // useEffect depending on what you pass it\n  // will fire once when the component first mounts []\n  // every time the comonent re-renders no second argument\n  // every time a var updates because we tell useEffect to watch it [someValueToWatch]\n  // OR\n  // fire the first time the component mounts\n  // this is really great for API calls or adding event listeners the old fashion way\n  // const useEffect(() => {}, [])\n  // fire on mount, and everytime the value uof myPeiceOfState changes\n  // const useEffect(() => {}, [myPieceOfState])\n  // if no second argument, it will fire every time the component re-renders\n  // const useEffect(() => {})\n\n  // fire once on mount to add event listener,\n  // if the function in the first agrument returns another function\n  // thats gets fired when the component is detroyed\n  // this is a cleanup function\n\n  /*\n  in our case, we want to add an event listener that:\n  listens for a click, and checks the event.target\n  WHY?\n  to close our dropdown when we click off our dropdown menu\n  (we opened the dropdown menu, but we never made a selection, and we then click off the dropdown anywhere else on the page!)\n  IMPORTANT STEP:\n  make sure you watch our divEl ref in our useEffect!!!\n  const useEffect(() => {}, [divEl])\n  IF YOU DONT:\n  the arrow function will only run ONCE ON MOUNT,\n  things will seem to work MOST of the time, but once the component is destroyed, a few too many clicks and you'll get an error screen\n  */\n  useEffect(() => {\n    // check the element assigned to const divEl (the most parent div in our dropdown)\n    // if what we just clicked is outside of this component\n    // close our dropdown!\n    const handler = (event) => {\n      // check that divEl.current exists before AND that it does not contain the event target\n      if (divEl.current && !divEl.current.contains(event.target)) {\n        setIsOpen(false)\n        console.log('clicked outside dropdown')\n      }\n    }\n\n    // add the event listener, this is for clicks OUTSIDE our dropdown component\n    // because of the conditional check above\n    document.addEventListener('click', handler, true)\n\n    // whenever we assign an event listener the old fashioned way : document.addEventListener\n    // we do it using useEffect(()=>{}, []) -  empty array as second argument!\n    // if we added an event listener without useEffect,\n    // it will add an event listener EVERY time the component re-renders!\n\n    // we have an event listener that affects our component,\n    // return a cleanup function to remove the event listener,\n    // if we dont, this event listener will hang around after\n    // our dropdown is no longer on the page and cause issues :(\n\n    // returned function inside useEffects first argument is fired whenever the component is destroyed\n    return () => {\n      document.removeEventListener('click', handler)\n    }\n  }, [divEl])\n\n  const handleClick = () => {\n    setIsOpen(!isOpen)\n  }\n\n  const handleOptionClick = (option) => {\n    setIsOpen(false)\n    // need some other function defined by the\n    // parent component passed in as a prop to call here\n    onChange(option)\n  }\n\n  const renderedOptions = options.map((opt, index) => {\n    // this is where we assign an element on the page to our divEl var!\n    // WHY? because we this components state (isOpen) to change when we click\n    // OUTSIDE THIS COMPONENT\n    return (\n      <div\n        onClick={() => handleOptionClick(opt)}\n        key={index}\n        className=\"hover:bg-sky-100 rounded cursor-pointer p-1\"\n      >\n        {opt.label}\n      </div>\n    )\n  })\n\n  return (\n    <div ref={divEl} className=\"w-48 relative\">\n      <Panel\n        onClick={handleClick}\n        className=\"flex justify-between items-center cursor-pointer\"\n      >\n        {/* if value exists (aka not null or undefined) find the value key within{{value?.value} */\n        /* great use of a ternary */}\n        {value ? value.label : 'Select...'} <GoChevronDown />\n      </Panel>\n      {isOpen && <Panel className=\"absolute top-full\">{renderedOptions}</Panel>}\n    </div>\n  )\n}\n\n/* moved to own file!\nconst Panel = (props) => {\n  const {className, children, ...rest} = props\n  const finalClassNames = cx(\n    className,\n    'border rounded p-3 shadow bg-white w-full'\n  )\n  return (\n    <div {...rest} className={finalClassNames}>\n      {children}\n    </div>\n  )\n}\n\n// named export\nexport {Panel}\n*/\n\n// default export (usually the file name should give you a hint about what to be the default export)\nexport default Dropdown\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}